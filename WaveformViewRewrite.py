#!/usr/bin/env python
# -*- coding: ISO-8859-1 -*-
# generated by wxGlade 0.3.5.1 on Thu Apr 21 12:10:56 2005

# Papagayo-NG, a lip-sync tool for use with several different animation suites
# Original Copyright (C) 2005 Mike Clifton
# Contact information at http://www.lostmarble.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import math, random
import PySide2.QtCore as QtCore
import PySide2.QtGui as QtGui
import PySide2.QtWidgets as QtWidgets
#from PySide2.QtWidgets import QtGui, QtCore, QtWidgets

from anytree import Node
import anytree.util

from LipsyncDoc import *

fill_color = QtGui.QColor(162, 205, 242)
line_color = QtGui.QColor(30, 121, 198)
frame_col = QtGui.QColor(192, 192, 192)
frame_text_col = QtGui.QColor(64, 64, 64)
play_back_col = QtGui.QColor(255, 127, 127)
play_fore_col = QtGui.QColor(209, 102, 121)
play_outline_col = QtGui.QColor(128, 0, 0)
text_col = QtGui.QColor(64, 64, 64)
phrase_fill_col = QtGui.QColor(205, 242, 162)
phrase_outline_col = QtGui.QColor(121, 198, 30)
word_fill_col = QtGui.QColor(242, 205, 162)
word_outline_col = QtGui.QColor(198, 121, 30)
phoneme_fill_col = QtGui.QColor(231, 185, 210)
phoneme_outline_col = QtGui.QColor(173, 114, 146)
font = QtGui.QFont("Swiss", 6)

# default_sample_width = 2
# default_samples_per_frame = 4
default_sample_width = 4
default_samples_per_frame = 2


class SceneWithDrag(QtWidgets.QGraphicsScene):
    def dragEnterEvent(self, e):
        e.acceptProposedAction()

    def dropEvent(self, e):
        # find item at these coordinates
        item = self.itemAt(e.scenePos(), QtGui.QTransform())
        if item:
            if item.setAcceptDrops:
                # pass on event to item at the coordinates
                item.dropEvent(e)
                try:
                    item.dropEvent(e)
                except RuntimeError:
                    pass  # This will suppress a Runtime Error generated when dropping into a widget with no MyProxy

    def dragMoveEvent(self, e):
        e.acceptProposedAction()


class MovableButton(QtWidgets.QPushButton):
    def __init__(self, lipsync_object, style, phoneme_offset=None):
        super(MovableButton, self).__init__(lipsync_object.text, None)
        self.title = lipsync_object.text
        self.node = None
        self.phoneme_offset = phoneme_offset
        self.lipsync_object = lipsync_object
        self.setStyleSheet(style)
        self.is_resizing = False
        # We need the parent element if it exists, and the previous and next element if they exist
        # When we move we need to check for the boundaries dictated by the parent and neighbours.
        # Inform our neighbours after we finished moving, should be automatic if references are used for that.
        # Getting new neighbours or loosing some is problematic.
        # Maybe a structure with all elements makes sense, it's a bit circular but should work.
        # It should somehow represent the actual data so that we can find our neighbours...
        # So the mov_widget_list should maybe be a list of lists instead
        # But to find our position in that we would have to parse through the whole list then...

    def get_left_max(self):
        left_most_pos = 0
        try:
            temp = self.get_left_sibling().name
            if not temp.lipsync_object.is_phoneme:
                left_most_pos = temp.lipsync_object.end_frame
            else:
                left_most_pos = temp.lipsync_object.frame
        except AttributeError:
            if self.node.depth > 1:
                left_most_pos = self.node.parent.name.lipsync_object.start_frame
            else:
                left_most_pos = 0
        return left_most_pos

    def get_right_max(self):
        right_most_pos = 0
        try:
            temp = self.get_right_sibling().name
            if not temp.lipsync_object.is_phoneme:
                right_most_pos = temp.lipsync_object.start_frame
            else:
                right_most_pos = temp.lipsync_object.frame
        except AttributeError:
            if self.node.depth > 1:
                right_most_pos = self.node.parent.name.lipsync_object.end_frame
            else:
                right_most_pos = self.lipsync_object.end_frame  # Last Phrase
        return right_most_pos

    def convert_to_pixels(self, frame_pos):
        if self.lipsync_object.is_phoneme:
            current_frame_pos = self.lipsync_object.frame
        else:
            current_frame_pos = self.lipsync_object.start_frame
        factor = self.x() / current_frame_pos
        return frame_pos * factor

    def convert_to_frames(self, pixel_pos):
        if self.lipsync_object.is_phoneme:
            current_frame_pos = self.lipsync_object.frame
        else:
            current_frame_pos = self.lipsync_object.start_frame
        factor = current_frame_pos / self.x()
        return pixel_pos * factor

    def mouseMoveEvent(self, event):
        if self.is_resizing:
            if round(self.convert_to_frames(event.x() + self.x())) >= self.lipsync_object.start_frame:
                if round(self.convert_to_frames(event.x() + self.x())) <= self.get_right_max():
                    self.lipsync_object.end_frame = round(self.convert_to_frames(event.x() + self.x()))
                    self.resize(self.convert_to_pixels(self.lipsync_object.end_frame) -
                                self.convert_to_pixels(self.lipsync_object.start_frame), self.height())
        else:
            pass  # Add dragging logic here

    def mousePressEvent(self, event):
        # Some debugging output
        try:
            print("MyLeftSibling: " + self.get_left_sibling().name.title)
        except AttributeError:
            pass
        try:
            print("MyRightSibling: " + self.get_right_sibling().name.title)
        except AttributeError:
            pass
        print("LeftMax: " + str(self.get_left_max()))
        print("RightMax: " + str(self.get_right_max()))
        print("BeginningPixel: " + str(self.x()))
        if self.lipsync_object.is_phoneme:
            print("BeginningFrame: " + str(self.lipsync_object.frame))
        else:
            print("BeginningFrame: " + str(self.lipsync_object.start_frame))
        print("EndPixel: " + str(self.x() + self.width()))
        if self.lipsync_object.is_phoneme:
            print("EndFrame: " + str(self.lipsync_object.frame))
        else:
            print("EndFrame: " + str(self.lipsync_object.end_frame))
        if self.lipsync_object.is_phoneme:
            print("Converted_to_Pixel: " + str(self.convert_to_pixels(self.lipsync_object.frame)))
        else:
            print("Converted_to_Pixel: " + str(self.convert_to_pixels(self.lipsync_object.start_frame)))
        print("Converted_to_frame: " + str(self.convert_to_frames(self.x())))
        print("ClickedPixel: " + str(self.x() + event.x()))
        print("ClickedFrame: " + str(self.convert_to_frames(self.x() + event.x())))

        # End of debugging output
        if event.buttons() == QtCore.Qt.LeftButton:
            if (self.width() - event.x()) < 10:
                if not self.lipsync_object.is_phoneme:
                    self.is_resizing = True
            else:
                self.is_resizing = False

    def mouseReleaseEvent(self, event):
        pass

    def mouseDoubleClickEvent(self, event):
        pass

    def get_left_sibling(self):
        return anytree.util.leftsibling(self.node)

    def get_right_sibling(self):
        return anytree.util.rightsibling(self.node)

    def __del__(self):
        try:
            self.deleteLater()
        except RuntimeError:
            pass

# class MovableButton(QtWidgets.QPushButton):
#     def __init__(self, title, me, style, parent, parent_obj=None, phoneme_offset=None):
#         super(MovableButton, self).__init__(title, None)
#         self.me = me
#         self.is_resizing = False
#         self.hotspot = 0
#         self.parent = parent
#         self.parent_object = parent_obj
#         self.left_edge = 0
#         self.right_edge = 0
#         self.left_most = 0
#         self.right_most = 0
#         self.phoneme_offset = phoneme_offset
#         self.calc_edges()
#         # self.setStyleSheet(f"background-color:rgb({phoneme_fill_col.red()},{phoneme_fill_col.green()},{phoneme_fill_col.blue()})")
#         # self.background_string = "background-color:rgb({0},{1},{2});".format(phoneme_fill_col.red(),
#         #                                                                      phoneme_fill_col.green(),
#         #                                                                      phoneme_fill_col.blue())
#         # self.background_string += "border:1px solid rgb({0},{1},{2});".format(phoneme_outline_col.red(),
#         #                                                                       phoneme_outline_col.green(),
#         #                                                                       phoneme_outline_col.blue())
#         self.setStyleSheet(style)
#
#     # def paintEvent(self, e):
#     #     QtWidgets.QPushButton.paintEvent(self, e)
#     #     painter = QtGui.QPainter(self)
#     #     background_brush = QtGui.QBrush(QtGui.QColor(255, 0, 0, 64), QtCore.Qt.SolidPattern)
#     #     pen = QtGui.QPen(QtGui.QColor(255, 255, 0, 255), 3, QtCore.Qt.DashDotLine, QtCore.Qt.RoundCap, QtCore.Qt.RoundJoin)
#     #     painter.setPen(pen)
#     #     rect = QtCore.QRectF(0, 0, self.width(), self.height())
#     #     # rect = QtCore.QRectF(self.x(), self.y(), self.x()+self.width(), self.y()+self.height())
#     #     painter.fillRect(rect, background_brush)
#
#     def mouseMoveEvent(self, e):
#
#         if e.buttons() != QtCore.Qt.LeftButton:
#             return
#         if ((e.pos().x() > self.width()-10) or self.is_resizing) and not self.me.is_phoneme:
#             if e.pos().x() > self.parent.frame_width + 10:  # TODO: Is this even needed? Seems Useless.
#                 if e.pos().x() <= self.right_edge:
#                     self.resize(e.pos().x(), self.height())
#                     self.is_resizing = True
#
#         else:
#             mime_data = QtCore.QMimeData()
#             drag = QtGui.QDrag(self)
#             drag.setMimeData(mime_data)
#             drag.setHotSpot(e.pos() - self.rect().topLeft())
#             print("HotSpot:")
#             print(drag.hotSpot())
#             self.hotspot = drag.hotSpot().x()
#             # PyQt5 and PySide use different function names here, likely a Qt4 vs Qt5 problem.
#             try:
#                 exec("dropAction = drag.exec(QtCore.Qt.MoveAction)")  # Otherwise we can't catch it and it will crash...
#             except (SyntaxError, AttributeError):
#                 dropAction = drag.start(QtCore.Qt.MoveAction)
#
#     def mousePressEvent(self, e):
#         # QtGui.QPushButton.mousePressEvent(self, e)
#         if e.button() == QtCore.Qt.RightButton and "phonemes" in dir(self.me):
#             # manually enter the pronunciation for this word
#             dlg = PronunciationDialog(self, self.parent.doc.parent.phonemeset.set)
#             dlg.word_label.setText(dlg.word_label.text() + ' ' + self.text())
#             prev_phoneme_list = ""
#             for p in self.me.phonemes:
#                 prev_phoneme_list += " " + p.text
#             dlg.phoneme_ctrl.setText(prev_phoneme_list)
#             if dlg.exec_():
#                 # Stupid workaround for the random crash, we add it here instead of in the draw routine.
#                 # If we did change the phonemes we delete here the existing ones from both lists
#                 for item in self.parent.scene().items():
#                     try:
#                         if item.widget().parent_object == self.me:
#                             self.parent.scene().removeItem(item)
#                     except AttributeError:
#                         pass
#
#                 for item in self.parent.mov_widget_list:
#                     if item.widget().parent_object == self.me:
#                         self.parent.mov_widget_list.remove(item)
#
#                 self.me.phonemes = []
#                 for phoneme_count, p in enumerate(dlg.phoneme_ctrl.text().split()):
#                     if len(p) == 0:
#                         continue
#                     phoneme = LipsyncPhoneme()
#                     phoneme.text = p
#                     phoneme.frame = self.me.end_frame
#                     self.me.phonemes.append(phoneme)
#                     # Here we add the new phonemes for this word to both lists
#                     font_metrics = QtGui.QFontMetrics(font)
#                     phoneme_col_string = "color: #000000; background-color:rgb({0},{1},{2});".format(
#                         phoneme_fill_col.red(),
#                         phoneme_fill_col.green(),
#                         phoneme_fill_col.blue())
#                     phoneme_col_string += "border:1px solid rgb({0},{1},{2});".format(phoneme_outline_col.red(),
#                                                                                       phoneme_outline_col.green(),
#                                                                                       phoneme_outline_col.blue())
#                     text_width, text_height = font_metrics.width("Ojyg"), font_metrics.height() + 6
#
#                     self.parent.mov_widget_list.append(self.parent.scene().addWidget(
#                         MovableButton(phoneme.text, phoneme, phoneme_col_string, self.parent, self.me,
#                                       phoneme_offset=phoneme_count % 2)))
#                     # self.mov_widget_list.append(self.scene().addWidget(MovableButton(phoneme.text, phoneme, phoneme_col_string, self, word)))
#                     # self.temp_phoneme = self.scene().addWidget(MovableButton(phoneme.text, phoneme, phoneme_col_string))
#                     self.parent.mov_widget_list[-1].setGeometry(QtCore.QRect(phoneme.frame * self.parent.frame_width,
#                                                                              self.height() - (
#                                                                                      self.parent.horizontalScrollBar().height() + 10 + text_height + (
#                                                                                      text_height * (
#                                                                                      phoneme_count % 2))),
#                                                                              self.parent.frame_width + 1,
#                                                                              text_height))
#                     self.parent.mov_widget_list[-1].setParent(self.parent)
#                     self.parent.mov_widget_list[-1].setZValue(99)
#                     # self.mov_widget_list[-1].parent_object = word # word seems to get gc'd and is then None
#                     phoneme.top = self.parent.mov_widget_list[-1].y()
#                     phoneme.bottom = self.parent.mov_widget_list[-1].y() + text_height
#                     #
#
#                 self.parent_object.reposition_word(self.me)
#                 # This might be the culprit
#                 self.parent.first_update = False
#                 self.parent.update_drawing()
#                 # Works quite good in theory but it seems to crash randomly. Debugging did not help.
#                 # self.parent.set_document(self.parent.doc)
#             else:
#                 print("No change!")
#
#     def mouseReleaseEvent(self, e):
#         print("Released")
#         new_right_edge = round((self.x() + self.width()) / self.parent.frame_width) - 1
#         self.calc_edges((-1, new_right_edge))
#         if self.is_resizing:
#             try:
#                 self.parent_object.reposition_word(self.me)
#             except AttributeError:
#                 self.parent.doc.current_voice.reposition_phrase(self.me, self.me.end_frame)
#         self.is_resizing = False
#         self.parent.first_update = False
#         self.parent.update_drawing()
#
#     def __del__(self):
#         try:
#             self.deleteLater()
#         except RuntimeError:
#             pass
#
#     def mouseDoubleClickEvent(self, e):
#         if not self.me.is_phoneme:
#             print("Double Click: ")
#             print(self.text())
#             start = self.me.start_frame / self.parent.doc.fps
#             length = (self.me.end_frame - self.me.start_frame) / self.parent.doc.fps
#             self.parent.doc.sound.play_segment(start, length)
#
#     def calc_edges(self, new_coords = None):
#         previous_one = None
#         next_one = None
#         parent = None
#
#         for index, phrase in enumerate(self.parent.doc.current_voice.phrases):
#             if self.me == phrase:
#                 #print("It's a phrase: " + phrase.text)
#                 #print(index)
#                 if index > 0:
#                     previous_one = self.parent.doc.current_voice.phrases[index-1]
#                 try:
#                     next_one = self.parent.doc.current_voice.phrases[index + 1]
#                 except IndexError:
#                     pass
#             else:
#                 for index1, word in enumerate(phrase.words):
#                     if self.me == word:
#                         #print("It's a word: " + word.text)
#                         #print(index1)
#                         parent = self.parent.doc.current_voice.phrases[index]
#                         if index1 > 0:
#                             previous_one = phrase.words[index1 - 1]
#                         else:
#                             if index > 0:
#                                 try:
#                                     previous_one = self.parent.doc.current_voice.phrases[index-1].words[-1]
#                                 except IndexError:
#                                     pass
#                         try:
#                             next_one = phrase.words[index1 + 1]
#                         except IndexError:
#                             try:
#                                 next_one = self.parent.doc.current_voice.phrases[index + 1].words[0]
#                             except IndexError:
#                                 pass
#                     else:
#                         for index2, phoneme in enumerate(word.phonemes):
#                             if self.me == phoneme:
#                                 #print("It's a phoneme: " + phoneme.text)
#                                 #print(index2)
#                                 parent = phrase.words[index1]
#                                 if index2 > 0:
#                                     previous_one = word.phonemes[index2 - 1]
#                                 else:
#                                     if index1 > 0:
#                                         try:
#                                             previous_one = phrase.words[index1 - 1].phonemes[-1]
#                                         except IndexError:
#                                             pass
#                                 try:
#                                     next_one = word.phonemes[index2 + 1]
#                                 except IndexError:
#                                     try:
#                                         next_one = phrase.words[index1 + 1].phonemes[0]
#                                     except IndexError:
#                                         pass
#         # if parent:
#         #     print("Parent : " + parent.text)
#         #     print(dir(parent))
#         # if previous_one:
#         #     print("Previous one: " + previous_one.text)
#         #     print(dir(previous_one))
#         # if next_one:
#         #     print("Next one: " + next_one.text)
#         #     print(dir(next_one))
#         # We should now have the previous and next object and it's parent here.
#
#         self.left_edge = 0
#         self.right_edge = 0
#         self.left_most = 0
#         self.right_most = 0
#
#         if previous_one:
#             if previous_one.is_phoneme:
#                 self.left_edge = previous_one.frame * self.parent.frame_width
#             else:
#                 self.left_edge = previous_one.end_frame * self.parent.frame_width
#         if next_one:
#             if next_one.is_phoneme:
#                 self.right_edge = next_one.frame * self.parent.frame_width
#             else:
#                 self.right_edge = next_one.start_frame * self.parent.frame_width
#         if parent:
#             self.left_most = parent.start_frame * self.parent.frame_width
#             self.right_most = parent.end_frame * self.parent.frame_width
#
#         if self.right_edge == 0:
#             self.right_edge = self.parent.scene().width()
#         self.left_edge = max(self.left_edge, self.left_most) + (1 * self.parent.frame_width)
#         if self.right_most:
#             self.right_edge = min(self.right_edge, self.right_most) + (1 * self.parent.frame_width)
#
#         # TODO: Some more testing is needed to see if dragging and resizing is correctly working
#
#         real_new_x = int(round(self.pos().x() / (self.parent.sample_width * self.parent.samples_per_frame)))
#         real_new_end = int(round(real_new_x + (self.width() / (self.parent.sample_width * self.parent.samples_per_frame))))
#         left_frame_edge = real_new_x  # round(self.left_edge / self.parent.frame_width)
#         right_frame_edge = real_new_end  # round(self.right_edge / self.parent.frame_width)
#         if new_coords:
#             if not self.me.is_phoneme:
#                 if new_coords[0] != -1:
#                     old_diff = self.me.end_frame - self.me.start_frame
#                     if True:  # (left_frame_edge < new_coords[0] < right_frame_edge) and (left_frame_edge < new_coords[0] + old_diff < right_frame_edge):
#                         self.me.start_frame = new_coords[0]
#                         self.me.end_frame = self.me.start_frame + old_diff
#                 if new_coords[1] != -1:
#                     if True:  # left_frame_edge < new_coords[1] < right_frame_edge:
#                         self.me.end_frame = new_coords[1]
#             else:
#                 if new_coords[0] != -1:
#                     if True:  # left_frame_edge < new_coords[0] < right_frame_edge:
#                         self.me.frame = new_coords[0] -1
#                 #else:
#                 #    if True:  # left_frame_edge < new_coords[1] < right_frame_edge:
#                 #        self.me.frame = new_coords[1]


class WaveformView(QtWidgets.QGraphicsView):
    def __init__(self, parent=None):
        super(WaveformView, self).__init__(parent)
        self.setScene(SceneWithDrag(self))
        self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)

        self.setAcceptDrops(True)
        self.setMouseTracking(True)

        # Other initialization
        self.doc = None
        self.is_dragging = False
        self.basic_scrubbing = False
        self.cur_frame = 0
        self.old_frame = 0
        self.sample_width = default_sample_width
        self.samples_per_frame = default_samples_per_frame
        self.samples_per_sec = 24 * self.samples_per_frame
        self.frame_width = self.sample_width * self.samples_per_frame
        self.phrase_bottom = 16
        self.word_bottom = 32
        self.phoneme_top = 128
        self.waveform_polygon = None
        self.wv_height = 1
        self.temp_phrase = None
        self.temp_word = None
        self.temp_phoneme = None
        self.temp_button = None
        self.draw_play_marker = False
        self.num_samples = 0
        self.list_of_lines = []
        self.amp = []
        self.temp_play_marker = None
        self.scroll_position = 0
        self.first_update = True
        self.node = None
        self.did_resize = None
        self.main_node = None
        # self.scene().setSceneRect(0,0,self.width(),self.height())

        print("LoadedWaveFormView")

    def drawBackground(self, painter, rect):
        background_brush = QtGui.QBrush(QtGui.QColor(255, 255, 255), QtCore.Qt.SolidPattern)
        painter.fillRect(rect, background_brush)
        if self.doc is not None:
            pen = QtGui.QPen(frame_col)
            # pen.setWidth(5)
            painter.setPen(pen)
            painter.setFont(font)

            first_sample = 0
            last_sample = len(self.amp)
            bg_height = self.height() + self.horizontalScrollBar().height()
            half_client_height = bg_height / 2
            font_metrics = QtGui.QFontMetrics(font)
            text_width, top_border = font_metrics.width("Ojyg"), font_metrics.height() * 2
            x = first_sample * self.sample_width
            frame = first_sample / self.samples_per_frame
            fps = int(round(self.doc.fps))
            sample = first_sample
            self.list_of_lines = []
            list_of_textmarkers = []
            for i in range(int(first_sample), int(last_sample)):
                if (i + 1) % self.samples_per_frame == 0:
                    frame_x = (frame + 1) * self.frame_width
                    if (self.frame_width > 2) or ((frame + 1) % fps == 0):
                        self.list_of_lines.append(QtCore.QLineF(frame_x, top_border, frame_x, bg_height))
                    # draw frame label
                    if (self.frame_width > 30) or ((int(frame) + 1) % 5 == 0):
                        self.list_of_lines.append(QtCore.QLineF(frame_x, 0, frame_x, top_border))
                        self.list_of_lines.append(QtCore.QLineF(frame_x + 1, 0, frame_x + 1, bg_height))
                        temp_rect = QtCore.QRectF(int(frame_x + 4), font_metrics.height() - 2, text_width, top_border)
                        # Positioning is a bit different in QT here
                        list_of_textmarkers.append((temp_rect, str(int(frame + 1))))
                x += self.sample_width
                sample += 1
                if sample % self.samples_per_frame == 0:
                    frame += 1
            painter.drawLines(self.list_of_lines)
            for text_marker in list_of_textmarkers:
                painter.drawText(text_marker[0], QtCore.Qt.AlignLeft, text_marker[1])
            if self.first_update:
                self.setSceneRect(self.scene().sceneRect())
                self.first_update = False

    def update_drawing(self, redraw_all=True):
        self.draw()

    def draw(self):
        print("Begin Drawing")

    def create_waveform(self):
        if self.waveform_polygon in self.scene().items():
            self.scene().removeItem(self.waveform_polygon)
        first_sample = 0
        last_sample = len(self.amp)
        top_and_bottom_space = 4  # This should in theory provide a bit of space at the top and bottom
        self.wv_height = self.height() + self.horizontalScrollBar().height() - top_and_bottom_space
        half_client_height = self.wv_height / 2
        x = first_sample * self.sample_width
        frame = first_sample / self.samples_per_frame
        sample = first_sample
        frame_rectangle_polygon_upper = []
        frame_rectangle_polygon_lower = []
        for i in range(int(first_sample), int(last_sample)):
            height = round(self.wv_height * self.amp[i]) + (top_and_bottom_space / 2)
            half_height = height / 2
            if self.draw_play_marker and (frame == self.cur_frame):
                pass
            else:
                # frame_rectangle_list.append((x, half_client_height - half_height, self.sample_width+1, height))
                # self.scene().addRect(x, half_client_height - half_height, self.sample_width+1, height, line_color, fill_color)
                frame_rectangle_polygon_upper.append((x, half_client_height - half_height))
                frame_rectangle_polygon_upper.append((x + self.sample_width, half_client_height - half_height))
                frame_rectangle_polygon_lower.append((x, half_client_height + half_height))
                frame_rectangle_polygon_lower.append((x + self.sample_width, half_client_height + half_height))
            x += self.sample_width
            sample += 1
            if sample % self.samples_per_frame == 0:
                frame += 1
        frame_rectangle_polygon_lower.reverse()
        temp_polygon = QtGui.QPolygonF()
        for coordinates in (frame_rectangle_polygon_upper + frame_rectangle_polygon_lower):
            temp_polygon.append(QtCore.QPointF(coordinates[0], coordinates[1]))
        self.waveform_polygon = self.scene().addPolygon(temp_polygon, line_color, fill_color)
        self.waveform_polygon.setZValue(1)

    def create_movbuttons(self):
        if self.doc is not None:
            phrase_col_string = "color: #000000; background-color:rgb({0},{1},{2});".format(phrase_fill_col.red(),
                                                                                            phrase_fill_col.green(),
                                                                                            phrase_fill_col.blue())
            phrase_col_string += "background-image: url(:/rsrc/marker.png); background-repeat: repeat-y; background-position: right;"
            phrase_col_string += "border:1px solid rgb({0},{1},{2});".format(phrase_outline_col.red(),
                                                                             phrase_outline_col.green(),
                                                                             phrase_outline_col.blue())

            word_col_string = "color: #000000; background-color:rgb({0},{1},{2});".format(word_fill_col.red(),
                                                                                          word_fill_col.green(),
                                                                                          word_fill_col.blue())
            word_col_string += "background-image: url(:/rsrc/marker.png); background-repeat: repeat-y; background-position: right;"

            word_col_string += "border:1px solid rgb({0},{1},{2});".format(word_outline_col.red(),
                                                                           word_outline_col.green(),
                                                                           word_outline_col.blue())
            phoneme_col_string = "color: #000000; background-color:rgb({0},{1},{2});".format(phoneme_fill_col.red(),
                                                                                             phoneme_fill_col.green(),
                                                                                             phoneme_fill_col.blue())
            phoneme_col_string += "border:1px solid rgb({0},{1},{2});".format(phoneme_outline_col.red(),
                                                                              phoneme_outline_col.green(),
                                                                              phoneme_outline_col.blue())
            font_metrics = QtGui.QFontMetrics(font)
            text_width, top_border = font_metrics.width("Ojyg"), font_metrics.height() * 2
            text_width, text_height = font_metrics.width("Ojyg"), font_metrics.height() + 6
            top_border += 4

            self.main_node = Node(self.doc.current_voice.text)  # Not actually needed, but should make everything a bit easier

            for phrase in self.doc.current_voice.phrases:
                self.temp_button = MovableButton(phrase, phrase_col_string)
                self.temp_button.node = Node(self.temp_button, parent=self.main_node)
                temp_scene_widget = self.scene().addWidget(self.temp_button)
                temp_scene_widget.setParent(self)
                temp_scene_widget.setGeometry(QtCore.QRect(phrase.start_frame * self.frame_width, top_border,
                                              (phrase.end_frame - phrase.start_frame) * self.frame_width + 1,
                                              text_height))
                temp_scene_widget.setZValue(99)
                self.temp_phrase = self.temp_button
                word_count = 0
                for word in phrase.words:
                    self.temp_button = MovableButton(word, word_col_string)
                    self.temp_button.node = Node(self.temp_button, parent=self.temp_phrase.node)
                    temp_scene_widget = self.scene().addWidget(self.temp_button)
                    temp_scene_widget.setParent(self)
                    temp_scene_widget.setGeometry(QtCore.QRect(word.start_frame * self.frame_width,
                                                  top_border + 4 + text_height + (text_height * (word_count % 2)),
                                                  (word.end_frame - word.start_frame ) * self.frame_width + 1,
                                                  text_height))
                    temp_scene_widget.setZValue(99)
                    self.temp_word = self.temp_button
                    word_count += 1
                    phoneme_count = 0
                    for phoneme in word.phonemes:
                        self.temp_button = MovableButton(phoneme, phoneme_col_string, phoneme_count % 2)
                        self.temp_button.node = Node(self.temp_button, parent=self.temp_word.node)
                        temp_scene_widget = self.scene().addWidget(self.temp_button)
                        temp_scene_widget.setParent(self)
                        temp_scene_widget.setGeometry(QtCore.QRect(phoneme.frame * self.frame_width,
                                                      self.height() - (self.horizontalScrollBar().height()*1.5) - (text_height + (text_height * (phoneme_count % 2))),
                                                      self.frame_width,
                                                      text_height))
                        temp_scene_widget.setZValue(99)
                        self.temp_phoneme = self.temp_button
                        phoneme_count += 1

    def set_document(self, document):
        self.doc = document
        if (self.doc is not None) and (self.doc.sound is not None):
            self.frame_width = self.sample_width * self.samples_per_frame
            duration = self.doc.sound.Duration()
            time = 0.0
            sample_dur = 1.0 / self.samples_per_sec
            max_amp = 0.0
            self.amp = []
            while time < duration:
                self.num_samples += 1
                amp = self.doc.sound.GetRMSAmplitude(time, sample_dur)
                self.amp.append(amp)
                if amp > max_amp:
                    max_amp = amp
                time += sample_dur
            # normalize amplitudes
            max_amp = 0.95 / max_amp
            for i in range(len(self.amp)):
                self.amp[i] *= max_amp
            self.scene().clear()
            self.scene().update()
            self.create_movbuttons()
        self.create_waveform()

    def on_slider_change(self, value):
        self.scroll_position = value

    def wheelEvent(self, event):
        self.scroll_position = self.horizontalScrollBar().value()+(event.delta()/1.2)
        self.horizontalScrollBar().setValue(self.scroll_position)

    def resizeEvent(self, event):
        update_rect = self.scene().sceneRect()
        width_factor = 1  # Only the height needs to change.
        # try:
        #     width_factor = self.width() / update_rect.width()
        # except ZeroDivisionError:
        #     width_factor = 1

        try:
            height_factor = event.size().height() / event.oldSize().height()
        except ZeroDivisionError:
            height_factor = 1
        update_rect.setHeight(event.size().height())
        self.setSceneRect(update_rect)
        if self.doc:
            origin_x, origin_y = 0, 0
            height_factor = height_factor * self.waveform_polygon.transform().m22()  # We need to add the factors
            self.waveform_polygon.setTransform(QtGui.QTransform().translate(
                origin_x, origin_y).scale(width_factor, height_factor).translate(-origin_x, -origin_y))
            # We need to at least update the Y Position of the Phonemes
            font_metrics = QtGui.QFontMetrics(font)
            text_width, top_border = font_metrics.width("Ojyg"), font_metrics.height() * 2
            text_width, text_height = font_metrics.width("Ojyg"), font_metrics.height() + 6
            top_border += 4
            for phoneme_node in self.main_node.leaves:  # this should be all phonemes
                widget = phoneme_node.name
                if widget.lipsync_object.is_phoneme:  # shouldn't be needed, just to be sure
                    widget.setGeometry(widget.x(),
                                       self.height() - (self.horizontalScrollBar().height()*1.5) - (text_height + (text_height * widget.phoneme_offset)),
                                       self.frame_width + 5,
                                       text_height)
        self.horizontalScrollBar().setValue(self.scroll_position)

    def on_zoom_in(self, event=None):
        if (self.doc is not None) and (self.samples_per_frame < 16):
            self.samples_per_frame *= 2
            self.samples_per_sec = self.doc.fps * self.samples_per_frame
            self.frame_width = self.sample_width * self.samples_per_frame
            self.set_document(self.doc)
            self.scene().setSceneRect(self.scene().sceneRect().x(), self.scene().sceneRect().y(),
                                      self.sceneRect().width() * 2, self.scene().sceneRect().height())
            self.setSceneRect(self.scene().sceneRect())
            self.scroll_position *= 2
            self.horizontalScrollBar().setValue(self.scroll_position)
            self.scene().update()

    def on_zoom_out(self, event=None):
        if (self.doc is not None) and (self.samples_per_frame > 1):
            self.samples_per_frame /= 2
            self.samples_per_sec = self.doc.fps * self.samples_per_frame
            self.frame_width = self.sample_width * self.samples_per_frame
            self.set_document(self.doc)
            self.scene().setSceneRect(self.scene().sceneRect().x(), self.scene().sceneRect().y(),
                                      self.scene().sceneRect().width() / 2, self.scene().sceneRect().height())
            self.setSceneRect(self.scene().sceneRect())

            self.scroll_position /= 2
            self.horizontalScrollBar().setValue(self.scroll_position)
            self.scene().update()

    def on_zoom_reset(self, event=None):
        if self.doc is not None:
            self.scroll_position /= (self.samples_per_frame / default_samples_per_frame)
            factor = (self.samples_per_frame / default_samples_per_frame)
            self.sample_width = default_sample_width
            self.samples_per_frame = default_samples_per_frame
            self.samples_per_sec = self.doc.fps * self.samples_per_frame
            self.frame_width = self.sample_width * self.samples_per_frame
            self.set_document(self.doc)
            self.scene().setSceneRect(self.scene().sceneRect().x(), self.scene().sceneRect().y(),
                                      self.scene().sceneRect().width() / factor, self.scene().sceneRect().height())
            self.setSceneRect(self.scene().sceneRect())
            self.horizontalScrollBar().setValue(self.scroll_position)
            self.scene().update()

# end of class WaveformView
