#!/usr/bin/env python
# -*- coding: ISO-8859-1 -*-
# generated by wxGlade 0.3.5.1 on Thu Apr 21 12:10:56 2005

# Papagayo-NG, a lip-sync tool for use with several different animation suites
# Original Copyright (C) 2005 Mike Clifton
# Contact information at http://www.lostmarble.com
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

import math, random
from qtpy import QtGui, QtCore, QtWidgets
# import wx
debug_performance = False
if debug_performance:
    import simplestopwatch as stopwatch
else:
    stopwatch = None

from LipsyncDoc import *

BUFFERED = 1
SIMPLE_DISPLAY = 0

fill_color = QtGui.QColor(162, 205, 242)
line_color = QtGui.QColor(30, 121, 198)
frame_col = QtGui.QColor(192, 192, 192)
frame_text_col = QtGui.QColor(64, 64, 64)
play_back_col = QtGui.QColor(255, 127, 127)
play_fore_col = QtGui.QColor(209, 102, 121)
play_outline_col = QtGui.QColor(128, 0, 0)
text_col = QtGui.QColor(64, 64, 64)
phrase_fill_col = QtGui.QColor(205, 242, 162)
phrase_outline_col = QtGui.QColor(121, 198, 30)
word_fill_col = QtGui.QColor(242, 205, 162)
word_outline_col = QtGui.QColor(198, 121, 30)
phoneme_fill_col = QtGui.QColor(231, 185, 210)
phoneme_outline_col = QtGui.QColor(173, 114, 146)
font = QtGui.QFont("Swiss", 6)

# default_sample_width = 2
# default_samples_per_frame = 4
default_sample_width = 4
default_samples_per_frame = 2


class SceneWithDrag(QtWidgets.QGraphicsScene):
    def dragEnterEvent(self, e):
        e.acceptProposedAction()

    def dropEvent(self, e):
        # find item at these coordinates
        item = self.itemAt(e.scenePos(), QtGui.QTransform())
        if item:
            if item.setAcceptDrops:
                # pass on event to item at the coordinates
                item.dropEvent(e)
                try:
                    item.dropEvent(e)
                except RuntimeError:
                    pass  # This will suppress a Runtime Error generated when dropping into a widget with no MyProxy

    def dragMoveEvent(self, e):
        e.acceptProposedAction()


class MovableButton(QtWidgets.QPushButton):
    def __init__(self, title, parent, style):
        super(MovableButton, self).__init__(title, parent, style)
        self.is_resizing = False
        self.hotspot = 0

        # self.setStyleSheet(f"background-color:rgb({phoneme_fill_col.red()},{phoneme_fill_col.green()},{phoneme_fill_col.blue()})")
        # self.background_string = "background-color:rgb({0},{1},{2});".format(phoneme_fill_col.red(),
        #                                                                      phoneme_fill_col.green(),
        #                                                                      phoneme_fill_col.blue())
        # self.background_string += "border:1px solid rgb({0},{1},{2});".format(phoneme_outline_col.red(),
        #                                                                       phoneme_outline_col.green(),
        #                                                                       phoneme_outline_col.blue())
        self.setStyleSheet(style)

    def mouseMoveEvent(self, e):

        if e.buttons() != QtCore.Qt.LeftButton:
            return
        if (e.pos().x() > self.width()-10) or self.is_resizing:
            if e.pos().x() > 0:
                self.resize(e.pos().x(), self.height())
                self.is_resizing = True
        else:
            mime_data = QtCore.QMimeData()

            drag = QtGui.QDrag(self)
            drag.setMimeData(mime_data)
            drag.setHotSpot(e.pos() - self.rect().topLeft())
            print("HotSpot:")
            print(drag.hotSpot())
            self.hotspot = drag.hotSpot().x()
            # PyQt5 and PySide use different function names here, likely a Qt4 vs Qt5 problem.
            # try:
            #     dropAction = drag.exec(QtCore.Qt.MoveAction)
            # except AttributeError:
            #     dropAction = drag.start(QtCore.Qt.MoveAction)
            dropAction = drag.start(QtCore.Qt.MoveAction)

    def mousePressEvent(self, e):
        # QtGui.QPushButton.mousePressEvent(self, e)
        if e.button() == QtCore.Qt.RightButton:
            print('press')
            print(self.text())

    def mouseReleaseEvent(self, e):
        self.is_resizing = False

    def __del__(self):
        try:
            self.deleteLater()
        except RuntimeError:
            pass

    def mouseDoubleClickEvent(self, e):
        print("Double Click: ")
        print(self.text())


class WaveformView(QtWidgets.QGraphicsView):
    def __init__(self, parent=None):
        super(WaveformView, self).__init__(parent)
        self.setScene(SceneWithDrag(self))
        self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)

        self.setAcceptDrops(True)
        self.setMouseTracking(True)
        self.__set_properties()
        self.__do_layout()

        # Other initialization
        self.doc = None
        self.max_width = 1
        self.max_height = 1
        self.is_dragging = False
        self.basic_scrubbing = False
        self.cur_frame = 0
        self.old_frame = 0
        self.buffer = None
        self.clip_rect = None
        self.sample_width = default_sample_width
        self.samples_per_frame = default_samples_per_frame
        self.samples_per_sec = 24 * self.samples_per_frame
        self.frame_width = self.sample_width * self.samples_per_frame
        self.phrase_bottom = 16
        self.word_bottom = 32
        self.phoneme_top = 128
        self.did_resize = 0
        self.waveform_polygon = None
        self.wv_height = 1
        self.temp_phrase = None
        self.temp_word = None
        self.temp_phoneme = None
        self.draw_play_marker = False
        self.num_samples = 0
        self.amp = []
        self.temp_play_marker = None
        self.idle_timer = QtCore.QTimer()
        self.idle_timer.setSingleShot(True)
        # self.idle_timer.singleShot(1000, self.do_idle)
        self.idle_timer.timeout.connect(self.do_idle)
        self.did_resize = False
        self.scroll_position = 0
        #
        # # Connect event handlers
        # # window events
        # wx.EVT_PAINT(self, self.OnPaint)
        # wx.EVT_SIZE(self, self.OnSize)
        # wx.EVT_IDLE(self, self.OnIdle)
        # # mouse events
        # wx.EVT_LEFT_DOWN(self, self.OnMouseDown)
        # wx.EVT_RIGHT_DOWN(self, self.OnMouseDown)
        # wx.EVT_LEFT_DCLICK(self, self.OnMouseDown)
        # wx.EVT_LEFT_UP(self, self.OnMouseUp)
        # wx.EVT_RIGHT_UP(self, self.OnMouseUp)
        # wx.EVT_MOTION(self, self.OnMouseMove)
        # wx.EVT_MOUSEWHEEL(self, self.OnMouseWheel)

        # Test drawing
        # Force an update
        self.OnSize()

    def __set_properties(self):
        # begin wxGlade: WaveformView.__set_properties
        # self.SetMinSize((200, 200))
        # self.SetBackgroundColour(wx.Colour(255, 255, 255))
        # self.SetScrollRate(10, 0)
        pass
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: WaveformView.__do_layout
        # self.Layout()
        pass
        # end wxGlade

    def dragEnterEvent(self, e):
        print("DragEnter!")
        e.accept()

    def dragMoveEvent(self, e):
        print("DragMove!")
        position = e.pos()
        print(e.pos())
        dropped_widget = e.source()
        dropped_widget.move(QtCore.QPoint(position.x() - e.source().hotspot, dropped_widget.y()))  # We keep the Y-Position
        # e.setDropAction(QtCore.Qt.MoveAction)
        e.accept()

    def dropMoveEvent(self, e):
        return

    def dropEvent(self, e):
        print("Dropped")

    def wheelEvent(self, event):
        self.scroll_position = self.horizontalScrollBar().value()+(event.delta()/1.2)
        self.horizontalScrollBar().setValue(self.scroll_position)

    def on_slider_change(self, value):
        self.scroll_position = value

    def resizeEvent(self, event):
        # for item in self.main_window.waveform_view.items():
        #     item.scale(1, self.height_scale)

        update_rect = self.scene().sceneRect()
        update_rect.setWidth(self.width())
        update_rect.setHeight(self.scene().height())
        self.fitInView(update_rect, QtCore.Qt.IgnoreAspectRatio)

        # This is buggy if we increase the window size after decreasing it, but the redraw after works.
        self.horizontalScrollBar().setValue(self.scroll_position)
        if not self.did_resize:
            self.did_resize = True
            self.idle_timer.start(500)

    def do_idle(self):
        try:
            self.update_drawing()
        except AttributeError:
            pass  # Not initialized yet
        update_rect = self.scene().sceneRect()
        update_rect.setWidth(self.width())
        update_rect.setHeight(
            self.height() - self.horizontalScrollBar().height())
        self.fitInView(update_rect, QtCore.Qt.IgnoreAspectRatio)
        update_rect = self.scene().sceneRect()
        self.scene().update(update_rect)
        self.horizontalScrollBar().setValue(self.scroll_position)
        self.idle_timer.stop()
        self.did_resize = False


    def OnIdle(self, event):
        # if self.didresize:
        #     if BUFFERED:
        #         # Initialize the buffer bitmap.  No real DC is needed at this point.
        #         if self.maxWidth > 0 and self.maxHeight > 0:
        #             self.buffer = wx.EmptyBitmap(self.maxWidth, self.maxHeight)
        #         else:
        #             self.buffer = None
        #         if stopwatch:
        #             t = stopwatch.Timer()
        #         self.UpdateDrawing()
        #         if stopwatch:
        #             t.stop()
        #             print("Updating took: " +str(t.elapsed))
        #     self.didresize = 0
        pass

    def OnPaint(self, event):
        # if BUFFERED:
        #     # Create a buffered paint DC.  It will create the real
        #     # wx.PaintDC and then blit the bitmap to it when dc is
        #     # deleted.  Since we don't need to draw anything else
        #     # here that's all there is to it.
        #     if self.buffer is not None:
        #         if 1:
        #             dc = wx.BufferedPaintDC(self, self.buffer, wx.BUFFER_VIRTUAL_AREA)
        #         else:
        #             dc = wx.BufferedPaintDC(self, self.buffer)
        #     else:
        #         event.Skip()
        # else:
        #     dc = wx.PaintDC(self)
        #     self.PrepareDC(dc)
        #     # since we're not buffering in this case, we have to
        #     # paint the whole window, potentially very time consuming.
        #     self.Draw(dc)
        pass


    def OnSize(self, event=None):
        # self.maxHeight = self.GetClientSize().height
        # self.SetVirtualSize((self.maxWidth, self.maxHeight))
        # self.didresize = 1
        pass

    def OnMouseDown(self, event):
        # self.isDragging = False
        # self.dragChange = False
        # self.draggingEnd = -1  # which end of the object (beginning or end) are you dragging
        # self.selectedPhrase = None
        # self.selectedWord = None
        # self.selectedPhoneme = None
        # x, y = event.GetPosition()
        # x, y = self.CalcUnscrolledPosition(x, y)
        # self.scrubFrame = x / self.frameWidth
        # self.lastFrame = self.scrubFrame
        # self.dragStartFrame = self.scrubFrame
        # if (self.doc is not None) and (self.doc.sound is not None) and (not self.doc.sound.IsPlaying()):
        #     self.isDragging = True
        #     if self.doc.currentVoice is not None:
        #         # test to see if the user clicked on a phrase, word, or phoneme
        #         # first, find the phrase that was clicked on
        #         for phrase in self.doc.currentVoice.phrases:
        #             if (self.scrubFrame >= phrase.startFrame) and (self.scrubFrame < phrase.endFrame + 1):
        #                 self.selectedPhrase = phrase
        #         # next, find the word that was clicked on
        #         if self.selectedPhrase is not None:
        #             for word in self.selectedPhrase.words:
        #                 if (self.scrubFrame >= word.startFrame) and (self.scrubFrame < word.endFrame + 1):
        #                     self.selectedWord = word
        #         # finally, find the phoneme that was clicked on
        #         if self.selectedWord is not None:
        #             for phoneme in self.selectedWord.phonemes:
        #                 if (self.scrubFrame >= phoneme.frame) and (self.scrubFrame < phoneme.frame + 1):
        #                     self.selectedPhoneme = phoneme
        #
        #         self.parentPhrase = self.selectedPhrase
        #         self.parentWord = self.selectedWord
        #
        #         # now, test if the click was within the vertical range of one of these objects
        #         if ( (self.selectedPhrase is not None)
        #          and (y > self.selectedPhrase.top)
        #          and (y < self.selectedPhrase.bottom) ):
        #             self.selectedWord = None
        #             self.selectedPhoneme = None
        #             self.draggingEnd = 0  # beginning of phrase
        #             dist = self.scrubFrame - self.selectedPhrase.startFrame
        #             if (self.selectedPhrase.endFrame - self.scrubFrame) < dist:
        #                 self.draggingEnd = 1  # end of phrase
        #                 dist = self.selectedPhrase.endFrame - self.scrubFrame
        #             if ( (self.selectedPhrase.endFrame - self.selectedPhrase.startFrame > 1)
        #              and (math.fabs((self.selectedPhrase.endFrame + self.selectedPhrase.startFrame)/2 - self.scrubFrame) < dist) ):
        #                 self.draggingEnd = 2  # middle of phrase
        #         elif ( (self.selectedWord is not None)
        #            and (y > self.selectedWord.top)
        #            and (y < self.selectedWord.bottom) ):
        #             self.selectedPhrase = None
        #             self.selectedPhoneme = None
        #             self.draggingEnd = 0  # beginning of word
        #             dist = self.scrubFrame - self.selectedWord.startFrame
        #             if (self.selectedWord.endFrame - self.scrubFrame) < dist:
        #                 self.draggingEnd = 1  # end of word
        #                 dist = self.selectedWord.endFrame - self.scrubFrame
        #             if ( (self.selectedWord.endFrame - self.selectedWord.startFrame > 1)
        #              and (math.fabs((self.selectedWord.endFrame + self.selectedWord.startFrame)/2 - self.scrubFrame) < dist) ):
        #                 self.draggingEnd = 2  # middle of word
        #         elif ( (self.selectedPhoneme is not None)
        #            and (y > self.selectedPhoneme.top)
        #            and (y < self.selectedPhoneme.bottom) ):
        #             self.selectedPhrase = None
        #             self.selectedWord = None
        #             self.draggingEnd = 0
        #         else:
        #             self.selectedPhrase = None
        #             self.selectedWord = None
        #             self.selectedPhoneme = None
        #
        #     self.basicScrubbing = False
        #     if (self.selectedPhrase is None) and (self.selectedWord is None) and (self.selectedPhoneme is None):
        #         self.basicScrubbing = True
        #         self.oldFrame = 0
        #         self.doc.sound.PlaySegment(float(self.scrubFrame) / float(self.doc.fps), 15.0 / self.doc.fps, 1.0)
        #         self.mouthView.SetFrame(self.scrubFrame)
        #         self.UpdateDrawing(False)
        #     elif event.RightIsDown() and self.selectedWord:
        #         self.isDragging = False
        #         # manually enter the pronunciation for this word
        #         dlg = PronunciationDialog(self, self.doc.parent.phonemeset.set)
        #         dlg.wordLabel.SetLabel(dlg.wordLabel.GetLabel() + ' ' + self.selectedWord.text)
        #         phonemeString = ""
        #         for p in self.selectedWord.phonemes:
        #             phonemeString += p.text + ' '
        #         dlg.phonemeCtrl.SetValue(phonemeString.strip())
        #         if dlg.ShowModal() == wx.ID_OK:
        #             self.doc.dirty = True
        #             self.selectedWord.phonemes = []
        #             for p in dlg.phonemeCtrl.GetValue().split():
        #                 if len(p) == 0:
        #                     continue
        #                 phoneme = LipsyncPhoneme()
        #                 phoneme.text = p
        #                 self.selectedWord.phonemes.append(phoneme)
        #             self.parentPhrase.RepositionWord(self.selectedWord)
        #             self.UpdateDrawing()
        #         dlg.Destroy()
        #         self.isDragging = False
        #         self.draggingEnd = -1  # which end of the object (beginning or end) are you dragging
        #         self.selectedPhrase = None
        #         self.selectedWord = None
        #         self.selectedPhoneme = None
        #     elif event.LeftDClick():
        #         playSegment = False
        #         if self.selectedPhrase is not None:
        #             playSegment = True
        #             self.doc.sound.PlaySegment(float(self.selectedPhrase.startFrame) / float(self.doc.fps),
        #                                        float(
        #                                            self.selectedPhrase.endFrame - self.selectedPhrase.startFrame + 1) / self.doc.fps,
        #                                        1.0)
        #         elif self.selectedWord is not None:
        #             playSegment = True
        #             self.doc.sound.PlaySegment(float(self.selectedWord.startFrame) / float(self.doc.fps),
        #                                        float(
        #                                            self.selectedWord.endFrame - self.selectedWord.startFrame + 1) / self.doc.fps,
        #                                        1.0)
        #         elif self.selectedPhoneme is not None:
        #             playSegment = True
        #             self.doc.sound.PlaySegment(float(self.selectedPhoneme.frame) / float(self.doc.fps),
        #                                        1.0 / self.doc.fps,
        #                                        1.0)
        #         self.isDragging = False
        #         self.draggingEnd = -1  # which end of the object (beginning or end) are you dragging
        #         self.selectedPhrase = None
        #         self.selectedWord = None
        #         self.selectedPhoneme = None
        #         if playSegment:
        #             frame = -1
        #             while self.doc.sound.IsPlaying():
        #                 nextFrame = int(math.floor(self.doc.sound.CurrentTime() * self.doc.fps))
        #                 if frame != nextFrame:
        #                     frame = nextFrame
        #                     self.mouthView.SetFrame(frame)
        #                     # self.SetFrame(frame) # I'm not sure if it's good to display the playback marker during this operation or not
        #                     self.TheApp.Yield()
        #                 wx.MilliSleep(250.0 / self.doc.fps)
        # if event.RightIsDown():
        #     self.isDragging = False
        #     self.draggingEnd = -1  # which end of the object (beginning or end) are you dragging
        #     self.selectedPhrase = None
        #     self.selectedWord = None
        #     self.selectedPhoneme = None
        # if self.isDragging:
        #     self.CaptureMouse()
        pass

    def OnMouseUp(self, event):
        # if self.isDragging:
        #     self.ReleaseMouse()
        #     self.isDragging = False
        #     self.scrubFrame = -1
        #     self.draggingEnd = -1
        #     self.selectedPhrase = None
        #     self.selectedWord = None
        #     self.selectedPhoneme = None
        #     if (self.doc is not None) and (self.doc.sound is not None):
        #         while self.doc.sound.IsPlaying():
        #             pass  # don't redraw until the playback for the last frame is done
        # self.didresize = True
        pass

    def OnMouseWheel(self, event):
        # if self.doc is not None:
        #     if event.ControlDown():
        #         if event.GetWheelRotation() > 0:
        #             self.OnZoomIn(event)
        #         else:
        #             self.OnZoomOut(event)
        #     else:
        #         x = self.GetScrollPos(wx.HORIZONTAL)
        #         self.Scroll(x - (event.GetWheelRotation() / 10), 0)
        pass

    def OnMouseMove(self, event):
        # if self.isDragging:
        #     try:
        #         x, y = event.GetPositionTuple()
        #     except AttributeError:
        #         x, y = event.GetLogicalPosition(self.cdc)
        #     x, y = self.CalcUnscrolledPosition(x, y)
        #     frame = x / self.frameWidth
        #     if frame == self.dragStartFrame:
        #         return
        #     self.dragStartFrame = -1000  # kick it far out of the way
        #
        #     if self.selectedPhrase is not None:
        #         if self.draggingEnd == 0:
        #             if frame != self.selectedPhrase.startFrame:
        #                 self.dragChange = True
        #                 self.doc.dirty = True
        #                 self.selectedPhrase.startFrame = frame
        #                 if self.selectedPhrase.startFrame > self.selectedPhrase.endFrame - 1:
        #                     self.selectedPhrase.startFrame = self.selectedPhrase.endFrame - 1
        #                 self.doc.currentVoice.RepositionPhrase(self.selectedPhrase, self.doc.soundDuration - 1)
        #         elif self.draggingEnd == 1:
        #             if frame != self.selectedPhrase.endFrame:
        #                 self.dragChange = True
        #                 self.doc.dirty = True
        #                 self.selectedPhrase.endFrame = frame
        #                 if self.selectedPhrase.endFrame < self.selectedPhrase.startFrame + 1:
        #                     self.selectedPhrase.endFrame = self.selectedPhrase.startFrame + 1
        #                 self.doc.currentVoice.RepositionPhrase(self.selectedPhrase, self.doc.soundDuration - 1)
        #         elif self.draggingEnd == 2:
        #             if frame != self.lastFrame:
        #                 self.dragChange = True
        #                 self.doc.dirty = True
        #                 self.selectedPhrase.startFrame += frame - self.lastFrame
        #                 self.selectedPhrase.endFrame += frame - self.lastFrame
        #                 self.doc.currentVoice.RepositionPhrase(self.selectedPhrase, self.doc.soundDuration - 1)
        #     elif self.selectedWord is not None:
        #         if self.draggingEnd == 0:
        #             if frame != self.selectedWord.startFrame:
        #                 self.dragChange = True
        #                 self.doc.dirty = True
        #                 self.selectedWord.startFrame = frame
        #                 if self.selectedWord.startFrame > self.selectedWord.endFrame - 1:
        #                     self.selectedWord.startFrame = self.selectedWord.endFrame - 1
        #                 self.parentPhrase.RepositionWord(self.selectedWord)
        #         elif self.draggingEnd == 1:
        #             if frame != self.selectedWord.endFrame:
        #                 self.dragChange = True
        #                 self.doc.dirty = True
        #                 self.selectedWord.endFrame = frame
        #                 if self.selectedWord.endFrame < self.selectedWord.startFrame:
        #                     self.selectedWord.endFrame = self.selectedWord.startFrame + 1
        #                 self.parentPhrase.RepositionWord(self.selectedWord)
        #         elif self.draggingEnd == 2:
        #             if frame != self.lastFrame:
        #                 self.dragChange = True
        #                 self.doc.dirty = True
        #                 self.selectedWord.startFrame += frame - self.lastFrame
        #                 self.selectedWord.endFrame += frame - self.lastFrame
        #                 self.parentPhrase.RepositionWord(self.selectedWord)
        #     elif self.selectedPhoneme is not None:
        #         if self.draggingEnd == 0:
        #             if frame != self.selectedPhoneme.frame:
        #                 self.dragChange = True
        #                 self.doc.dirty = True
        #                 self.selectedPhoneme.frame = frame
        #                 self.parentWord.RepositionPhoneme(self.selectedPhoneme)
        #
        #     if (frame != self.scrubFrame) and (self.doc is not None) and (
        #                 self.doc.sound is not None):  # and (not self.doc.sound.IsPlaying()):
        #         self.oldFrame = self.scrubFrame
        #         self.scrubFrame = frame
        #         self.doc.sound.PlaySegment(float(self.scrubFrame) / float(self.doc.fps), 15.0 / self.doc.fps, 1.0)
        #         self.mouthView.SetFrame(self.scrubFrame)
        #         self.UpdateDrawing(not self.basicScrubbing)
        #         self.lastFrame = self.scrubFrame
        pass

    def set_frame(self, frame):
        self.centerOn(self.temp_play_marker)
        self.temp_play_marker.setPos(
            frame * self.frame_width, 0)
        # update_rect = QtCore.QRectF(self.main_window.waveform_view.temp_play_marker.x() - self.main_window.waveform_view.temp_play_marker.rect().width(),
        #                             self.main_window.waveform_view.temp_play_marker.y(),
        #                             self.main_window.waveform_view.temp_play_marker.rect().width() * 2,
        #                             self.main_window.waveform_view.temp_play_marker.rect().height())
        update_rect = self.scene().sceneRect()
        self.scene().update(update_rect)

    def set_document(self, doc):
        if (self.doc is None) and (doc is not None):
            self.sample_width = default_sample_width
            self.samples_per_frame = default_samples_per_frame
            self.samples_per_sec = doc.fps * self.samples_per_frame
            self.frame_width = self.sample_width * self.samples_per_frame
        self.doc = doc
        self.num_samples = 0
        self.amp = []
        self.max_width = 32
        self.max_height = 32
        if (self.doc is not None) and (self.doc.sound is not None):
            self.frame_width = self.sample_width * self.samples_per_frame
            duration = self.doc.sound.Duration()
            time = 0.0
            sample_dur = 1.0 / self.samples_per_sec
            max_amp = 0.0
            while time < duration:
                self.num_samples += 1
                amp = self.doc.sound.GetRMSAmplitude(time, sample_dur)
                self.amp.append(amp)
                if amp > max_amp:
                    max_amp = amp
                time += sample_dur
            # normalize amplitudes
            max_amp = 0.95 / max_amp
            for i in range(len(self.amp)):
                self.amp[i] *= max_amp
            self.max_width = (self.num_samples + 1) * self.sample_width
            self.wv_height = self.height() - self.horizontalScrollBar().height()
            self.max_height = self.wv_height
        elif self.doc is not None:
            self.max_width = self.doc.sound_duration * self.frame_width
            self.wv_height = self.height() - self.horizontalScrollBar().height()
            self.max_height = self.wv_height
        print(self.amp)
        self.update_drawing()
        
        # self.SetVirtualSize((self.maxWidth, self.maxHeight))
        # # clear the current waveform
        # dc = wx.ClientDC(self)
        # self.PrepareDC(dc)
        # dc.SetBackground(wx.Brush(self.GetBackgroundColour()))
        # dc.Clear()
        # if BUFFERED:
        #     # Initialize the buffer bitmap.  No real DC is needed at this point.
        #     if self.maxWidth > 0 and self.maxHeight > 0:
        #         self.buffer = wx.EmptyBitmap(self.maxWidth, self.maxHeight)
        #     else:
        #         self.buffer = None
        #     self.UpdateDrawing()
        pass

    def update_drawing(self, redraw_all=True):
        self.draw()
        # if BUFFERED and self.buffer is None:
        #     print("Oh no!")
        #     return
        # self.clipRect = None
        # if (self.doc is not None) and (self.doc.sound is not None):
        #     cs = self.GetClientSize()
        #     if self.isDragging and self.basicScrubbing and (not redrawAll):
        #         firstSample = self.oldFrame * self.samplesPerFrame
        #         lastSample = self.scrubFrame * self.samplesPerFrame
        #         if firstSample > lastSample:
        #             firstSample, lastSample = lastSample, firstSample
        #         firstSample -= self.samplesPerFrame * 2
        #         lastSample += self.samplesPerFrame * 3
        #         self.clipRect = wx.Rect((firstSample + 1) * self.sampleWidth, 0,
        #                                 (lastSample - firstSample - 2) * self.sampleWidth, cs.height)
        #     elif self.doc.sound.IsPlaying() and (not redrawAll):
        #         if self.curFrame >= self.oldFrame:
        #             self.clipRect = wx.Rect(self.oldFrame * self.frameWidth, 0,
        #                                     (self.curFrame - self.oldFrame + 2) * self.frameWidth, cs.height)
        # if BUFFERED:
        #     # If doing buffered drawing, create the buffered DC, giving it
        #     # it a real DC to blit to when done.
        #     cdc = wx.ClientDC(self)
        #     self.PrepareDC(cdc)
        #     # print(self.clipRect)
        #     if self.clipRect is not None:
        #         if not self.isWxPhoenix:
        #             cdc.SetClippingRect(self.clipRect)
        #         else:
        #             # WxWidgets - Phoenix
        #             cdc.SetClippingRegion(self.clipRect)
        #     dc = wx.BufferedDC(cdc, self.buffer)
        #     if self.clipRect is not None:
        #         if not self.isWxPhoenix:
        #             dc.SetClippingRect(self.clipRect)
        #         else:
        #             # WxWidgets - Phoenix
        #             dc.SetClippingRegion(self.clipRect)
        #     self.Draw(dc)
        #     if ((self.doc is not None) and (self.doc.sound is not None)) and self.doc.sound.IsPlaying():
        #         self.Draw(cdc)
        # else:
        #     dc = wx.ClientDC(self)
        #     self.PrepareDC(dc)
        #     if self.clipRect is not None:
        #         if not self.isWxPhoenix:
        #             dc.SetClippingRect(self.clipRect)
        #         else:
        #             # WxWidgets - Phoenix
        #             dc.SetClippingRegion(self.clipRect)
        #     self.Draw(dc)
        pass

    # def resize(self, new_height):
    #     old_height = self.waveform_polygon.boundingRect().height()
    #     factor = old_height / new_height
    #     self.waveform_polygon.translate(1, factor)

    def drawForeground(self, painter, rect):
        # We might draw the play marker here instead.
        # if self.draw_play_marker:
        #     foreground_brush = QtGui.QBrush(play_fore_col, QtCore.Qt.SolidPattern)
        #     outline = QtGui.QPen(play_outline_col)
        #     painter.fillRect()
        pass

    def drawBackground(self, painter, rect):
        background_brush = QtGui.QBrush(QtGui.QColor(255, 255, 255), QtCore.Qt.SolidPattern)
        painter.fillRect(rect, background_brush)
        if self.doc is not None:
            pen = QtGui.QPen(frame_col)
            # pen.setWidth(5)
            painter.setPen(pen)
            painter.setFont(font)

            first_sample = 0
            last_sample = len(self.amp)
            self.wv_height = self.scene().height()  # - self.horizontalScrollBar().height()
            half_client_height = self.wv_height / 2
            font_metrics = QtGui.QFontMetrics(font)
            text_width, top_border = font_metrics.width("Ojyg"), font_metrics.height() * 2
            x = first_sample * self.sample_width
            frame = first_sample / self.samples_per_frame
            fps = int(round(self.doc.fps))
            sample = first_sample
            list_of_lines = []
            list_of_textmarkers = []
            for i in range(int(first_sample), int(last_sample)):
                if (i + 1) % self.samples_per_frame == 0:
                    frame_x = (frame + 1) * self.frame_width
                    if (self.frame_width > 2) or ((frame + 2) % fps == 0):
                        list_of_lines.append(QtCore.QLineF(frame_x, top_border, frame_x, self.wv_height))
                    # draw frame label
                    if (self.frame_width > 30) or ((int(frame) + 2) % 5 == 0):
                        list_of_lines.append(QtCore.QLineF(frame_x, 0, frame_x, top_border))
                        list_of_lines.append(QtCore.QLineF(frame_x + 1, 0, frame_x + 1, self.wv_height))
                        temp_rect = QtCore.QRectF(int(frame_x + 4), font_metrics.height() - 2, text_width, top_border)
                        # Positioning is a bit different in QT here
                        list_of_textmarkers.append((temp_rect, str(int(frame + 2))))
                x += self.sample_width
                sample += 1
                if sample % self.samples_per_frame == 0:
                    frame += 1
            painter.drawLines(list_of_lines)
            for text_marker in list_of_textmarkers:
                painter.drawText(text_marker[0], QtCore.Qt.AlignLeft, text_marker[1])

    def draw(self):
        print("Begin Drawing")
        # fill_color = QtGui.QColor(162, 205, 242)
        # line_color = QtGui.QColor(30, 121, 198)
        # frame_col = QtGui.QColor(192, 192, 192)
        # frame_text_col = QtGui.QColor(64, 64, 64)
        # play_back_col = QtGui.QColor(255, 127, 127)
        # play_fore_col = QtGui.QColor(209, 102, 121)
        # play_outline_col = QtGui.QColor(128, 0, 0)
        # text_col = QtGui.QColor(64, 64, 64)
        # phrase_fill_col = QtGui.QColor(205, 242, 162)
        # phrase_outline_col = QtGui.QColor(121, 198, 30)
        # word_fill_col = QtGui.QColor(242, 205, 162)
        # word_outline_col = QtGui.QColor(198, 121, 30)
        # phoneme_fill_col = QtGui.QColor(231, 185, 210)
        # phoneme_outline_col = QtGui.QColor(173, 114, 146)
        # font = QtGui.QFont("Swiss", 6)
        self.draw_play_marker = False
        # TestWaveform
        print("before clear")
        self.scene().clear()
        print("cleared")
        first_sample = 0
        last_sample = len(self.amp)
        self.wv_height = self.height()  # - self.horizontalScrollBar().height()
        half_client_height = self.wv_height / 2
        font_metrics = QtGui.QFontMetrics(font)
        text_width, top_border = font_metrics.width("Ojyg"), font_metrics.height() * 2
        x = first_sample * self.sample_width
        frame = first_sample / self.samples_per_frame
        fps = int(round(self.doc.fps))
        sample = first_sample
        last_height = -1
        last_half_height = 1
        amp = 0
        frame_rectangle_list = []
        frame_rectangle_polygon_upper = []
        frame_rectangle_polygon_lower = []
        if stopwatch:
            t2 = stopwatch.Timer()
        for i in range(int(first_sample), int(last_sample)):
            if stopwatch:
                if i % 100 == 0:
                    print("Sample " + str(i) + " Time " + str(t2.elapsed))
            height = round(self.wv_height * self.amp[i])
            half_height = height / 2
            if self.draw_play_marker and (frame == self.cur_frame):
                pass
            else:
                # frame_rectangle_list.append((x, half_client_height - half_height, self.sample_width+1, height))
                # self.scene().addRect(x, half_client_height - half_height, self.sample_width+1, height, line_color, fill_color)
                frame_rectangle_polygon_upper.append((x, half_client_height - half_height))
                frame_rectangle_polygon_upper.append((x + self.sample_width, half_client_height - half_height))
                frame_rectangle_polygon_lower.append((x, half_client_height + half_height))
                frame_rectangle_polygon_lower.append((x + self.sample_width, half_client_height + half_height))
            x += self.sample_width
            sample += 1
            if sample % self.samples_per_frame == 0:
                frame += 1
        frame_rectangle_polygon_lower.reverse()
        temp_polygon = QtGui.QPolygonF()
        for coordinates in (frame_rectangle_polygon_upper + frame_rectangle_polygon_lower):
            temp_polygon.append(QtCore.QPointF(coordinates[0], coordinates[1]))
        self.waveform_polygon = self.scene().addPolygon(temp_polygon, line_color, fill_color)

        # # Here we use a Button to simulate our phonemes, currently get's regenerated.
        # test_button = self.scene().addWidget(MovableButton("test", None))
        # test_button.setGeometry(QtCore.QRectF(20, 20, font_metrics.width(test_button.widget().text()), font_metrics.height()))
        # test_button2 = self.scene().addWidget(MovableButton("test2", None))
        # test_button2.setGeometry(QtCore.QRectF(60, 20, font_metrics.width(test_button2.widget().text()), font_metrics.height()))
        self.temp_phrase = None
        self.temp_word = None
        self.temp_phoneme = None
        phrase_col_string = "background-color:rgb({0},{1},{2});".format(phrase_fill_col.red(),
                                                                        phrase_fill_col.green(),
                                                                        phrase_fill_col.blue())
        phrase_col_string += "border:1px solid rgb({0},{1},{2});".format(phrase_outline_col.red(),
                                                                         phrase_outline_col.green(),
                                                                         phrase_outline_col.blue())
        word_col_string = "background-color:rgb({0},{1},{2});".format(word_fill_col.red(),
                                                                      word_fill_col.green(),
                                                                      word_fill_col.blue())
        word_col_string += "border:1px solid rgb({0},{1},{2});".format(word_outline_col.red(),
                                                                       word_outline_col.green(),
                                                                       word_outline_col.blue())
        phoneme_col_string = "background-color:rgb({0},{1},{2});".format(phoneme_fill_col.red(),
                                                                         phoneme_fill_col.green(),
                                                                         phoneme_fill_col.blue())
        phoneme_col_string += "border:1px solid rgb({0},{1},{2});".format(phoneme_outline_col.red(),
                                                                          phoneme_outline_col.green(),
                                                                          phoneme_outline_col.blue())

        if self.doc.current_voice is not None:
            top_border += 4
            text_width, text_height = font_metrics.width("Ojyg"), font_metrics.height() + 6
            # self.phrase_bottom = top_border + text_height
            # self.word_bottom = top_border + 4 + (text_height * 3)
            # self.phoneme_top = self.height() - 4 - (text_height * 2)
            for phrase in self.doc.current_voice.phrases:
                self.temp_phrase = self.scene().addWidget(MovableButton(phrase.text, None, phrase_col_string))
                self.temp_phrase.setGeometry(QtCore.QRectF(phrase.start_frame * self.frame_width,
                                                           top_border,
                                                           (phrase.endFrame - phrase.start_frame + 1) * self.frame_width +1,
                                                           text_height))
                phrase.top = self.temp_phrase.y()
                phrase.bottom = self.temp_phrase.y() + text_height
                word_count = 0
                for word in phrase.words:
                    self.temp_word = self.scene().addWidget(MovableButton(word.text, None, word_col_string))
                    self.temp_word.setGeometry(QtCore.QRectF(word.start_frame * self.frame_width,
                                                             top_border + 4 + text_height + (text_height * (word_count % 2)),
                                                             (word.endFrame - word.start_frame + 1) * self.frame_width + 1,
                                                             text_height))
                    word.top = self.temp_word.y()
                    word.bottom = self.temp_word.y() + text_height
                    word_count += 1
                    phoneme_count = 0
                    for phoneme in word.phonemes:
                        self.temp_phoneme = self.scene().addWidget(MovableButton(phoneme.text, None, phoneme_col_string))
                        self.temp_phoneme.setGeometry(QtCore.QRectF(phoneme.frame * self.frame_width,
                                                                    self.height() - (self.horizontalScrollBar().height() + 10 + text_height + (text_height * (phoneme_count % 2))),
                                                                    self.frame_width + 1,
                                                                    text_height))
                        phoneme.top = self.temp_phoneme.y()
                        phoneme.bottom = self.temp_phoneme.y() + text_height
                        phoneme_count += 1

        # This doesn't do anything yet because this method is not running all the time.
        # We should create an object and make it in/visible on demand and move it.
        print("Playing, now drawing marker!")
        x = self.cur_frame * self.frame_width
        #     foreground_brush = QtGui.QBrush(play_fore_col, QtCore.Qt.SolidPattern)
        #     outline = QtGui.QPen(play_outline_col)
        self.temp_play_marker = self.scene().addRect(x,
                                                     0,
                                                     self.frame_width + 1,
                                                     self.height() - self.horizontalScrollBar().height(),
                                                     QtGui.QPen(play_outline_col),
                                                     QtGui.QBrush(play_fore_col, QtCore.Qt.SolidPattern))
        self.temp_play_marker.setOpacity(0.5)
        self.temp_play_marker.setVisible(False)
        if self.doc.sound.is_playing():
            self.temp_play_marker.setVisible(True)
        # if not self.doc.sound.is_playing():
        #     self.temp_play_marker.setVisible(False)
        # else:
        #     self.temp_play_marker.setVisible(True)
        # # draw the play marker
        # if drawPlayMarker:
        #     x = curFrame * self.frameWidth
        #     # foreground
        #     height = round(cs.height * amp)
        #     # outline
        #     dc.SetBrush(wx.TRANSPARENT_BRUSH)
        #     dc.SetPen(wx.Pen(playOutlineCol))
        #     dc.DrawRectangle(x, 0, self.frameWidth + 1, cs.height)
        #     # Draw Big Fat Frame Marker
        #     if self.isDragging:
        #         dc.DestroyClippingRegion()
        #         font.SetPointSize(16)
        #         font.SetWeight(wx.BOLD)
        #         dc.SetFont(font)
        #         dc.DrawLabel(str(curFrame + 1), wx.Rect(x - 50, cs.height * 0.4, 100, 125), wx.ALIGN_CENTER)

        # # draw the phrases/words/phonemes
        # if self.doc.currentVoice is not None:
        #     topBorder += 4
        #     font.SetPointSize(8)
        #     font.SetWeight(wx.BOLD)
        #     dc.SetFont(font)
        #     textWidth, textHeight = dc.GetTextExtent("Ojyg")
        #     textHeight += 6
        #     self.phraseBottom = topBorder + textHeight
        #     self.wordBottom = topBorder + 4 + textHeight + textHeight + textHeight
        #     self.phonemeTop = cs.height - 4 - textHeight - textHeight
        #     dc.SetTextForeground(textCol)
        #     for phrase in self.doc.currentVoice.phrases:
        #         dc.SetBrush(wx.Brush(phraseFillCol))
        #         dc.SetPen(wx.Pen(phraseOutlineCol))
        #         r = wx.Rect(phrase.startFrame * self.frameWidth, topBorder,
        #                     (phrase.endFrame - phrase.startFrame + 1) * self.frameWidth + 1, textHeight)
        #         if (self.clipRect is not None) and (not r.Intersects(self.clipRect)):
        #             continue  # speed things up by skipping off-screen phrases
        #         phrase.top = r.y
        #         phrase.bottom = r.y + r.height
        #         dc.DrawRectangle(r.x, r.y, r.width, r.height)
        #         r.Inflate(-4, 0)
        #         if not self.isWxPhoenix:
        #             dc.SetClippingRect(r)
        #         else:
        #             # WxWidgets - Phoenix
        #             dc.SetClippingRegion(r)
        #         dc.DrawLabel(phrase.text, r, wx.ALIGN_LEFT | wx.ALIGN_CENTER_VERTICAL)
        #         dc.DestroyClippingRegion()
        #         if self.clipRect is not None:
        #             if not self.isWxPhoenix:
        #                 dc.SetClippingRect(self.clipRect)
        #             else:
        #                 # WxWidgets - Phoenix
        #                 dc.SetClippingRegion(self.clipRect)
        #
        #         wordCount = 0
        #         for word in phrase.words:
        #             dc.SetBrush(wx.Brush(wordFillCol))
        #             dc.SetPen(wx.Pen(wordOutlineCol))
        #             r = wx.Rect(word.startFrame * self.frameWidth, topBorder + 4 + textHeight,
        #                         (word.endFrame - word.startFrame + 1) * self.frameWidth + 1, textHeight)
        #             if wordCount % 2:
        #                 r.y += textHeight
        #             word.top = r.y
        #             word.bottom = r.y + r.height
        #             dc.DrawRectangle(r.x, r.y, r.width, r.height)
        #             r.Inflate(-4, 0)
        #             if not self.isWxPhoenix:
        #                 dc.SetClippingRect(r)
        #             else:
        #                 # WxWidgets - Phoenix
        #                 dc.SetClippingRegion(r)
        #             dc.DrawLabel(word.text, r, wx.ALIGN_LEFT | wx.ALIGN_CENTER_VERTICAL)
        #             dc.DestroyClippingRegion()
        #             if self.clipRect is not None:
        #                 if not self.isWxPhoenix:
        #                     dc.SetClippingRect(self.clipRect)
        #                 else:
        #                     # WxWidgets - Phoenix
        #                     dc.SetClippingRegion(self.clipRect)
        #             dc.SetBrush(wx.Brush(phonemeFillCol))
        #             dc.SetPen(wx.Pen(phonemeOutlineCol))
        #             phonemeCount = 0
        #             for phoneme in word.phonemes:
        #                 r = wx.Rect(phoneme.frame * self.frameWidth, cs.height - 4 - textHeight, self.frameWidth + 1,
        #                             textHeight)
        #                 if phonemeCount % 2:
        #                     r.y -= textHeight
        #                 phoneme.top = r.y
        #                 phoneme.bottom = r.y + r.height
        #                 dc.DrawRectangle(r.x, r.y, r.width, r.height)
        #                 dc.DrawLabel(phoneme.text, r, wx.ALIGN_LEFT | wx.ALIGN_CENTER_VERTICAL)
        #                 phonemeCount += 1
        #             wordCount += 1

        # self.wv_height = self.height() - self.horizontalScrollBar().height()
        # print(self.wv_height)
        # self.wv_pen = QtGui.QPen(QtCore.Qt.darkBlue)
        # self.wv_brush = QtGui.QBrush(QtCore.Qt.blue)
        # for i in range(5000):
        #     self.scene().addLine(10 * i, 0, 10 * i, self.wv_height)
        #     self.scene().addRect(10 * i, 0, 10, random.randrange(self.wv_height), self.wv_pen,
        #                          self.wv_brush)
        print("End Drawing")
        # if stopwatch:
        #     t2 = stopwatch.Timer()
        # if self.doc is None:
        #     # dc.BeginDrawing()
        #     dc.SetBackground(wx.Brush(self.GetBackgroundColour()))
        #     dc.Clear()
        #     # dc.EndDrawing()
        #     return
        # fillColor = wx.Colour(162, 205, 242)
        # lineColor = wx.Colour(30, 121, 198)
        # frameCol = wx.Colour(192, 192, 192)
        # frameTextCol = wx.Colour(64, 64, 64)
        # playBackCol = wx.Colour(255, 127, 127)
        # playForeCol = wx.Colour(209, 102, 121)
        # playOutlineCol = wx.Colour(128, 0, 0)
        # textCol = wx.Colour(64, 64, 64)
        # phraseFillCol = wx.Colour(205, 242, 162)
        # phraseOutlineCol = wx.Colour(121, 198, 30)
        # wordFillCol = wx.Colour(242, 205, 162)
        # wordOutlineCol = wx.Colour(198, 121, 30)
        # phonemeFillCol = wx.Colour(231, 185, 210)
        # phonemeOutlineCol = wx.Colour(173, 114, 146)
        # font = wx.Font(6, wx.SWISS, wx.NORMAL, wx.NORMAL)
        # drawPlayMarker = False
        # curFrame = self.curFrame
        # cs = self.GetClientSize()
        # halfClientHeight = cs.height / 2
        # # dc.BeginDrawing()
        # dc.SetBackground(wx.Brush(self.GetBackgroundColour()))
        # dc.Clear()
        # firstSample = 0
        # lastSample = len(self.amp)
        # if (self.doc is not None) and (self.doc.sound is not None) and self.doc.sound.IsPlaying() and (
        #         not self.isDragging):
        #     if curFrame >= self.oldFrame:
        #         firstSample = (self.oldFrame - 1) * self.samplesPerFrame
        #         if firstSample < 0:
        #             firstSample = 0
        #         lastSample = (curFrame + 2) * self.samplesPerFrame
        #         if lastSample > len(self.amp):
        #             lastSample = len(self.amp)
        #     drawPlayMarker = True
        #     x = curFrame * self.frameWidth
        #     # print("OldFrame: ",self.oldFrame)
        #     # print("X for cursor :", x)
        #     # background of playback marker
        #     dc.SetBrush(wx.Brush(playBackCol))
        #     dc.SetPen(wx.TRANSPARENT_PEN)
        #     dc.DrawRectangle(x, 0, self.frameWidth + 1, cs.height)
        # elif self.isDragging:
        #     scrollX, scrollY = self.CalcScrolledPosition(0, 0)
        #     firstSample = int(-scrollX / self.sampleWidth) - 1
        #     if self.basicScrubbing:
        #         firstSample = self.oldFrame * self.samplesPerFrame
        #     lastSample = firstSample + int(cs.width / self.sampleWidth) + 3
        #     if self.basicScrubbing:
        #         lastSample = self.scrubFrame * self.samplesPerFrame
        #         if firstSample > lastSample:
        #             firstSample, lastSample = lastSample, firstSample
        #         firstSample -= self.samplesPerFrame * 2
        #         lastSample += self.samplesPerFrame * 3
        #     if firstSample < 0:
        #         firstSample = 0
        #     if firstSample > len(self.amp):
        #         firstSample = len(self.amp)
        #     if lastSample < 0:
        #         lastSample = 0
        #     if lastSample > len(self.amp):
        #         lastSample = len(self.amp)
        #     drawPlayMarker = True
        #     curFrame = self.scrubFrame
        #     x = curFrame * self.frameWidth
        #     # background of playback marker
        #     dc.SetBrush(wx.Brush(playBackCol))
        #     dc.SetPen(wx.TRANSPARENT_PEN)
        #     dc.DrawRectangle(x, 0, self.frameWidth + 1, cs.height)
        # # draw the audio samples
        # dc.SetBrush(wx.Brush(fillColor))
        # dc.SetPen(wx.Pen(lineColor))
        # dc.SetTextForeground(frameTextCol)
        # dc.SetFont(font)
        # textWidth, topBorder = dc.GetTextExtent("Ojyg")
        # x = firstSample * self.sampleWidth
        # frame = firstSample / self.samplesPerFrame
        # fps = int(round(self.doc.fps))
        # sample = firstSample
        # lastHeight = -1
        # lastHalfHeight = 1
        # amp = 0
        # faster_drawing = True
        # for i in range(int(firstSample), int(lastSample)):
        #     if stopwatch:
        #         if i % 100 == 0:
        #             print("Sample " + str(i) + " Time " + str(t2.elapsed))
        #     if (sample + 1) % self.samplesPerFrame == 0:
        #         # draw frame marker
        #         dc.SetPen(wx.Pen(frameCol))  # +0.06 seconds
        #         frameX = (frame + 1) * self.frameWidth
        #         # print("framex: ",frameX)
        #         if (self.frameWidth > 2) or ((frame + 2) % fps == 0):
        #             dc.DrawLine(frameX, topBorder, frameX, cs.height)  # +0.01 seconds
        #         # draw frame label
        #         if (self.frameWidth > 30) or ((frame + 2) % 5 == 0):
        #             # These three take about 0.01 seconds
        #             dc.DrawLine(frameX, 0, frameX, topBorder)
        #             dc.DrawLine(frameX + 1, 0, frameX + 1, cs.height)
        #             dc.DrawLabel(str(frame + 2), wx.Rect(frameX + 1, 0, 128, 128))
        #         dc.SetBrush(wx.Brush(fillColor))  # +0.04 seconds
        #         dc.SetPen(wx.Pen(lineColor))  # +0.07 seconds
        #     amp = self.amp[i]
        #     height = round(cs.height * amp)
        #     halfHeight = height / 2
        #     if drawPlayMarker and (frame == curFrame):
        #         dc.SetBrush(wx.Brush(playForeCol))
        #         dc.SetPen(wx.TRANSPARENT_PEN)
        #     if SIMPLE_DISPLAY:
        #         dc.DrawLine(x, halfClientHeight - halfHeight, x, halfClientHeight + halfHeight)
        #     else:
        #         dc.DrawRectangle(x, halfClientHeight - halfHeight, self.sampleWidth + 1, height)  # Only doing this takes 0.12 seconds
        #         if not faster_drawing:
        #             if drawPlayMarker and (frame == curFrame):
        #                 dc.SetBrush(wx.Brush(fillColor))
        #                 dc.SetPen(wx.Pen(lineColor))
        #             if lastHeight > 0 and not (drawPlayMarker and frame == curFrame):
        #                 if lastHeight > height:
        #                     lastHeight = height
        #                     lastHalfHeight = halfHeight
        #                 dc.SetPen(wx.Pen(fillColor))  # +0.16 seconds
        #                 dc.DrawLine(x, halfClientHeight - lastHalfHeight + 1, x, halfClientHeight + lastHalfHeight - 1)
        #                 dc.SetPen(wx.Pen(lineColor))  # +0.175 seconds
        #     x += self.sampleWidth
        #     sample += 1
        #     if sample % self.samplesPerFrame == 0:
        #         frame += 1
        #         """
        #         # draw frame markers
        #         frameX = frame * self.frameWidth
        #         dc.SetPen(wx.Pen(frameCol))
        #         dc.DrawLine(frameX, topBorder, frameX, cs.height)
        #         dc.SetBrush(wx.Brush(fillColor))
        #         dc.SetPen(wx.Pen(lineColor))
        #         """
        #     lastHeight = height
        #     lastHalfHeight = halfHeight
        # if faster_drawing:
        #     # This fills in the lines between samples. Doing this separately saves between 0.11 and 0.25 seconds here.
        #     dc.SetBrush(wx.Brush(fillColor))
        #     dc.SetPen(wx.Pen(lineColor))
        #     dc.SetTextForeground(frameTextCol)
        #     dc.SetFont(font)
        #     textWidth, topBorder = dc.GetTextExtent("Ojyg")
        #     x = firstSample * self.sampleWidth
        #     frame = firstSample / self.samplesPerFrame
        #     fps = int(round(self.doc.fps))
        #     sample = firstSample
        #     lastHeight = -1
        #     lastHalfHeight = 1
        #     amp = 0
        #     dc.SetPen(wx.Pen(fillColor))
        #     for i in range(int(firstSample), int(lastSample)):
        #         amp = self.amp[i]
        #         height = round(cs.height * amp)
        #         halfHeight = height / 2
        #         if not SIMPLE_DISPLAY:
        #             if drawPlayMarker and (frame == curFrame):
        #                 dc.SetBrush(wx.Brush(fillColor))
        #                 dc.SetPen(wx.Pen(lineColor))
        #             if lastHeight > 0 and not (drawPlayMarker and frame == curFrame):
        #                 if lastHeight > height:
        #                     lastHeight = height
        #                     lastHalfHeight = halfHeight
        #                 dc.DrawLine(x, halfClientHeight - lastHalfHeight + 1, x, halfClientHeight + lastHalfHeight - 1)
        #         x += self.sampleWidth
        #         sample += 1
        #         if sample % self.samplesPerFrame == 0:
        #             frame += 1
        #             """
        #             # draw frame markers
        #             frameX = frame * self.frameWidth
        #             dc.SetPen(wx.Pen(frameCol))
        #             dc.DrawLine(frameX, topBorder, frameX, cs.height)
        #             dc.SetBrush(wx.Brush(fillColor))
        #             dc.SetPen(wx.Pen(lineColor))
        #             """
        #         lastHeight = height
        #         lastHalfHeight = halfHeight
        #     dc.SetPen(wx.Pen(lineColor))
        #
        # # draw the phrases/words/phonemes
        # if self.doc.currentVoice is not None:
        #     topBorder += 4
        #     font.SetPointSize(8)
        #     font.SetWeight(wx.BOLD)
        #     dc.SetFont(font)
        #     textWidth, textHeight = dc.GetTextExtent("Ojyg")
        #     textHeight += 6
        #     self.phraseBottom = topBorder + textHeight
        #     self.wordBottom = topBorder + 4 + textHeight + textHeight + textHeight
        #     self.phonemeTop = cs.height - 4 - textHeight - textHeight
        #     dc.SetTextForeground(textCol)
        #     for phrase in self.doc.currentVoice.phrases:
        #         dc.SetBrush(wx.Brush(phraseFillCol))
        #         dc.SetPen(wx.Pen(phraseOutlineCol))
        #         r = wx.Rect(phrase.startFrame * self.frameWidth, topBorder,
        #                     (phrase.endFrame - phrase.startFrame + 1) * self.frameWidth + 1, textHeight)
        #         if (self.clipRect is not None) and (not r.Intersects(self.clipRect)):
        #             continue  # speed things up by skipping off-screen phrases
        #         phrase.top = r.y
        #         phrase.bottom = r.y + r.height
        #         dc.DrawRectangle(r.x, r.y, r.width, r.height)
        #         r.Inflate(-4, 0)
        #         if not self.isWxPhoenix:
        #             dc.SetClippingRect(r)
        #         else:
        #             # WxWidgets - Phoenix
        #             dc.SetClippingRegion(r)
        #         dc.DrawLabel(phrase.text, r, wx.ALIGN_LEFT | wx.ALIGN_CENTER_VERTICAL)
        #         dc.DestroyClippingRegion()
        #         if self.clipRect is not None:
        #             if not self.isWxPhoenix:
        #                 dc.SetClippingRect(self.clipRect)
        #             else:
        #                 # WxWidgets - Phoenix
        #                 dc.SetClippingRegion(self.clipRect)
        #
        #         wordCount = 0
        #         for word in phrase.words:
        #             dc.SetBrush(wx.Brush(wordFillCol))
        #             dc.SetPen(wx.Pen(wordOutlineCol))
        #             r = wx.Rect(word.startFrame * self.frameWidth, topBorder + 4 + textHeight,
        #                         (word.endFrame - word.startFrame + 1) * self.frameWidth + 1, textHeight)
        #             if wordCount % 2:
        #                 r.y += textHeight
        #             word.top = r.y
        #             word.bottom = r.y + r.height
        #             dc.DrawRectangle(r.x, r.y, r.width, r.height)
        #             r.Inflate(-4, 0)
        #             if not self.isWxPhoenix:
        #                 dc.SetClippingRect(r)
        #             else:
        #                 # WxWidgets - Phoenix
        #                 dc.SetClippingRegion(r)
        #             dc.DrawLabel(word.text, r, wx.ALIGN_LEFT | wx.ALIGN_CENTER_VERTICAL)
        #             dc.DestroyClippingRegion()
        #             if self.clipRect is not None:
        #                 if not self.isWxPhoenix:
        #                     dc.SetClippingRect(self.clipRect)
        #                 else:
        #                     # WxWidgets - Phoenix
        #                     dc.SetClippingRegion(self.clipRect)
        #             dc.SetBrush(wx.Brush(phonemeFillCol))
        #             dc.SetPen(wx.Pen(phonemeOutlineCol))
        #             phonemeCount = 0
        #             for phoneme in word.phonemes:
        #                 r = wx.Rect(phoneme.frame * self.frameWidth, cs.height - 4 - textHeight, self.frameWidth + 1,
        #                             textHeight)
        #                 if phonemeCount % 2:
        #                     r.y -= textHeight
        #                 phoneme.top = r.y
        #                 phoneme.bottom = r.y + r.height
        #                 dc.DrawRectangle(r.x, r.y, r.width, r.height)
        #                 dc.DrawLabel(phoneme.text, r, wx.ALIGN_LEFT | wx.ALIGN_CENTER_VERTICAL)
        #                 phonemeCount += 1
        #             wordCount += 1
        # # draw the play marker
        # if drawPlayMarker:
        #     x = curFrame * self.frameWidth
        #     # foreground
        #     height = round(cs.height * amp)
        #     # outline
        #     dc.SetBrush(wx.TRANSPARENT_BRUSH)
        #     dc.SetPen(wx.Pen(playOutlineCol))
        #     dc.DrawRectangle(x, 0, self.frameWidth + 1, cs.height)
        #     # Draw Big Fat Frame Marker
        #     if self.isDragging:
        #         dc.DestroyClippingRegion()
        #         font.SetPointSize(16)
        #         font.SetWeight(wx.BOLD)
        #         dc.SetFont(font)
        #         dc.DrawLabel(str(curFrame + 1), wx.Rect(x - 50, cs.height * 0.4, 100, 125), wx.ALIGN_CENTER)
        # try:
        #     dc.EndDrawing()
        # except AttributeError:
        #     pass
        # if stopwatch:
        #     t2.stop()
        #     print("Drawing took: " + str(t2.elapsed))
        pass

    def on_zoom_in(self, event=None):
        if (self.doc is not None) and (self.samples_per_frame < 16):
            self.samples_per_frame *= 2
            self.samples_per_sec = self.doc.fps * self.samples_per_frame
            self.frame_width = self.sample_width * self.samples_per_frame
            self.set_document(self.doc)
            self.scroll_position *= 2
            self.horizontalScrollBar().setValue(self.scroll_position)

    def on_zoom_out(self, event=None):
        if (self.doc is not None) and (self.samples_per_frame > 1):
            self.samples_per_frame /= 2
            self.samples_per_sec = self.doc.fps * self.samples_per_frame
            self.frame_width = self.sample_width * self.samples_per_frame
            self.set_document(self.doc)
            self.scroll_position /= 2
            self.horizontalScrollBar().setValue(self.scroll_position)

    def on_zoom_reset(self, event=None):
        if self.doc is not None:
            self.scroll_position /= (self.samples_per_frame / default_samples_per_frame)
            self.sample_width = default_sample_width
            self.samples_per_frame = default_samples_per_frame
            self.samples_per_sec = self.doc.fps * self.samples_per_frame
            self.frame_width = self.sample_width * self.samples_per_frame
            self.set_document(self.doc)
            self.horizontalScrollBar().setValue(self.scroll_position)

# end of class WaveformView
